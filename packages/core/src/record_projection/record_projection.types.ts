import type { RecordStores } from '../record_store';
import type { RecordMetrics } from '../record_metrics';
import type {
  TaskRecord,
  GitGovTaskRecord,
  GitGovCycleRecord,
  GitGovFeedbackRecord,
  GitGovExecutionRecord,
  GitGovChangelogRecord,
  GitGovActorRecord
} from '../record_types';
import type { SystemStatus, ProductivityMetrics, CollaborationMetrics } from '../record_metrics';
import type { ActivityEvent } from '../event_bus';

/**
 * Collection of all records with full GitGov metadata (headers + payloads).
 * This allows access to signatures, checksums, and other metadata for enrichment.
 *
 * @see GitGovTaskRecord - Full record type with header.signatures for author/lastModifier extraction
 */
export type AllRecords = {
  tasks: GitGovTaskRecord[];
  cycles: GitGovCycleRecord[];
  feedback: GitGovFeedbackRecord[];
  executions: GitGovExecutionRecord[];
  changelogs: GitGovChangelogRecord[];
  actors: GitGovActorRecord[];
};

/**
 * System-wide derived states for dashboard analytics and filtering.
 * Calculated by calculateDerivedStates() during index generation.
 *
 * @see derived_data_protocol.md for calculation algorithms
 */
export type DerivedStates = {
  stalledTasks: string[];
  atRiskTasks: string[];
  needsClarificationTasks: string[];
  blockedByDependencyTasks: string[];
};

/**
 * Optimized version of DerivedStates using Sets for O(1) lookup performance.
 * Used internally by enrichTaskRecord() to efficiently check task membership.
 *
 * Conversion from DerivedStates (arrays) to DerivedStateSets (Sets) happens once
 * in generateIndex() before processing multiple tasks, avoiding repeated O(n) lookups.
 */
export type DerivedStateSets = {
  stalledTasks: Set<string>;
  atRiskTasks: Set<string>;
  needsClarificationTasks: Set<string>;
  blockedByDependencyTasks: Set<string>;
};

/**
 * Enhanced Task Record with complete intelligence layer.
 * Calculated by enrichTaskRecord() with relationships, metrics, and derived states.
 *
 * @see record_projection.md Section 3.6 - EnrichedTaskRecord Specification (EARS 25-48)
 */
export type EnrichedTaskRecord = TaskRecord & {
  derivedState: {
    isStalled: boolean;
    isAtRisk: boolean;
    needsClarification: boolean;
    isBlockedByDependency: boolean;
    healthScore: number;
    timeInCurrentStage: number;
  };
  relationships: {
    author?: { actorId: string; timestamp: number };
    lastModifier?: { actorId: string; timestamp: number };
    assignedTo: Array<{ actorId: string; assignedAt?: number }>;
    dependsOn: string[];
    blockedBy: string[];
    cycles: Array<{ id: string; title: string }>;
  };
  metrics: {
    executionCount: number;
    blockingFeedbackCount: number;
    openQuestionCount: number;
    timeToResolution?: number;
  };
  release: {
    isReleased: boolean;
    lastReleaseVersion?: string;
  };
  lastUpdated: number;
  lastActivityType: 'task_modified' | 'feedback_received' | 'execution_added' | 'changelog_created' | 'task_created';
  recentActivity?: string;
};

/**
 * IndexData - Complete cached index structure.
 * Generated by generateIndex() and consumed by CLI/Dashboard.
 */
export type IndexData = {
  metadata: {
    generatedAt: string;
    lastCommitHash: string;
    integrityStatus: 'valid' | 'warnings' | 'errors';
    recordCounts: Record<string, number>;
    generationTime: number;
  };
  metrics: SystemStatus & ProductivityMetrics & CollaborationMetrics;
  derivedStates: DerivedStates;
  activityHistory: ActivityEvent[];
  tasks: GitGovTaskRecord[];
  enrichedTasks: EnrichedTaskRecord[];
  cycles: GitGovCycleRecord[];
  actors: GitGovActorRecord[];
  feedback: GitGovFeedbackRecord[];
};

/**
 * Integrity validation error types.
 */
export type IntegrityError = {
  type: 'schema_violation' | 'checksum_failure' | 'signature_invalid';
  recordId: string;
  message: string;
};

/**
 * Integrity validation warning types.
 */
export type IntegrityWarning = {
  type: 'missing_reference' | 'deprecated_field' | 'performance_issue';
  recordId: string;
  message: string;
};

/**
 * Result of validateIntegrity() operation.
 */
export type IntegrityReport = {
  status: 'valid' | 'warnings' | 'errors';
  recordsScanned: number;
  errorsFound: IntegrityError[];
  warningsFound: IntegrityWarning[];
  validationTime: number;
  checksumFailures: number;
  signatureFailures: number;
};

/**
 * Result of generateIndex() operation.
 */
export type IndexGenerationReport = {
  success: boolean;
  recordsProcessed: number;
  metricsCalculated: number;
  derivedStatesApplied: number;
  generationTime: number;
  errors: string[];
  performance: {
    readTime: number;
    calculationTime: number;
    writeTime: number;
  };
};

/**
 * Context for projection operations.
 * Provides metadata about the projection target.
 */
export type ProjectionContext = {
  repoIdentifier?: string;
  lastCommitHash?: string;
};

/**
 * IRecordProjection - Driver pattern for projection output.
 *
 * Abstracts where IndexData is persisted. Implementations:
 * - FsRecordProjection: writes to .gitgov/index.json (CLI)
 * - MemoryRecordProjection: in-memory Map (tests)
 * - PrismaRecordProjection: decomposes into Prisma tables (SaaS)
 */
export interface IRecordProjection {
  persist(data: IndexData, context: ProjectionContext): Promise<void>;
  read(context: ProjectionContext): Promise<IndexData | null>;
  exists(context: ProjectionContext): Promise<boolean>;
  clear(context: ProjectionContext): Promise<void>;
}

/**
 * RecordProjector Dependencies - Facade + Dependency Injection Pattern.
 *
 * @see record_projection.md Section 2 - Architecture
 */
export type RecordProjectorDependencies = {
  recordMetrics: RecordMetrics;
  stores: Required<Pick<RecordStores, 'tasks' | 'cycles' | 'feedbacks' | 'executions' | 'changelogs' | 'actors'>>;
  sink?: IRecordProjection;
};

/**
 * RecordProjector Interface - The Projection Engine.
 */
export interface IRecordProjector {
  generateIndex(): Promise<IndexGenerationReport>;
  computeProjection(opts?: { lastCommitHash?: string }): Promise<IndexData>;
  getIndexData(): Promise<IndexData | null>;
  validateIntegrity(): Promise<IntegrityReport>;
  calculateDerivedStates(allRecords: AllRecords): Promise<DerivedStates>;
  calculateActivityHistory(allRecords: AllRecords): Promise<ActivityEvent[]>;
  calculateLastUpdated(
    task: GitGovTaskRecord,
    relatedRecords: AllRecords
  ): Promise<{
    lastUpdated: number;
    lastActivityType: EnrichedTaskRecord['lastActivityType'];
    recentActivity: string;
  }>;
  enrichTaskRecord(
    task: GitGovTaskRecord,
    relatedRecords: AllRecords,
    derivedStateSets: DerivedStateSets
  ): Promise<EnrichedTaskRecord>;
  isIndexUpToDate(): Promise<boolean>;
  invalidateCache(): Promise<void>;
}
