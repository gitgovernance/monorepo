{
  "header": {
    "version": "1.0",
    "type": "task",
    "payloadChecksum": "92c06044813c02225f84c7e3524c60b15c1869ceae2bbeffae7c4c92af5153c7",
    "signatures": [
      {
        "keyId": "human:camilo",
        "role": "author",
        "notes": "Signature regenerated by lint --fix",
        "signature": "TLeQYxmDtvKsuS1gQECD2eCFiVEsQJ3hGze4k9gjOwb2SOwgmwLfrLI7x8Y0Wv1s4OlFxNai05TFHcl27NPaCw==",
        "timestamp": 1762658229
      },
      {
        "keyId": "human:camilo-v2",
        "role": "author",
        "notes": "Record signed",
        "signature": "edmfFn+N058CLRwq1PXMPMQM9pKvg2VLNx99bubCDuHJYtLJeaTJg9KXH1ueInt4ceB0ZJNKJD9XAPy2U0BhAQ==",
        "timestamp": 1763344818
      }
    ]
  },
  "payload": {
    "id": "1761604714-task-verificar-coherencia-completa-de-planningmethodolo",
    "title": "Verify complete coherence of PlanningMethodology: Protocol, Command, Adapter, Schema and Code",
    "status": "draft",
    "priority": "medium",
    "description": "# Verificar coherencia completa de PlanningMethodology: Protocol, Command, Adapter, Schema y Código\n\n## Contexto\n\nSiguiendo el proceso sistemático de revisión de 5 capas que aplicamos con `FeedbackAdapter` y otros protocolos, ahora toca revisar el `PlanningMethodologyAdapter`. Este protocolo define las **reglas de descomposición de tasks complejas** y **epic management**.\n\n**Nota crítica:** PlanningMethodology es un **enhancement opcional** (a diferencia de WorkflowMethodology que es obligatorio). Se usa para descomponer tasks épicas en sub-tasks manejables.\n\n## Trabajo Previo Completado (Referencia Feedback)\n\nProceso de 5 capas aplicado exitosamente:\n\n### 1. Coherencia de Protocol + Documentos Adicionales con Command\n- ✅ Verificamos protocol + FAQ\n- ✅ Contrastamos con command\n- ✅ Identificamos inconsistencias\n- ✅ Actualizamos todos los documentos\n\n### 2. Coherencia de Protocol/Command con Adapter Blueprint\n- ✅ Revisamos adapter blueprint + FAQ\n- ✅ Verificamos que blueprint refleje protocol\n- ✅ Reescribimos secciones necesarias\n\n### 3. Coherencia de las 3 Capas\n- ✅ Verificación cruzada Protocol ↔ Command ↔ Adapter\n- ✅ EARS consistentes entre documentos\n\n### 4. Refactor de Implementación Real\n- ✅ Revisamos código del adapter\n- ✅ Refactorizamos según blueprint\n- ✅ Actualizamos tests\n- ✅ Verificamos coherencia arquitectural\n\n### 5. Verificación de Schema Generabilidad\n- ✅ Verificamos que protocol puede generar schema completo\n- ✅ Usamos `task_protocol.md` como referencia\n- ✅ Confirmamos maxLength, patterns, enums completos\n\n## Objetivo de Esta Task\n\nAplicar el **proceso de 5 capas** a `PlanningMethodology`:\n\n### Capa 1: Verificar Protocol ↔ Command (PENDIENTE)\n\n**Documentos a revisar:**\n- `packages/blueprints/03_products/protocol/11_planning_methodology/planning_methodology_protocol.md` (si existe)\n- `packages/blueprints/03_products/protocol/11_planning_methodology/planning_methodology_protocol_faq.md` (si existe)\n- `packages/blueprints/03_products/cli/specs/planning_command.md` (si existe)\n\n**Verificar:**\n- ❓ ¿Protocol existe y está documentado?\n- ❓ ¿Existe comando CLI `gitgov planning`?\n- ❓ ¿Define estructura de PlanningMethodologyRecord?\n- ❓ ¿Documenta epic decomposition?\n- ❓ ¿Documenta agent routing?\n- ❓ ¿Documenta artifact generation?\n\n**Posibilidad:** Puede que este protocolo **NO EXISTA AÚN** (está marcado como futuro en varios lugares). En ese caso, esta task se convierte en \"Documentar Planning Methodology Protocol desde cero\".\n\n### Capa 2: Verificar Protocol/Command ↔ Adapter Blueprint (PENDIENTE)\n\n**Documentos a revisar:**\n- `packages/blueprints/03_products/core/specs/adapters/planning_methodology_adapter.md` (si existe)\n- `packages/blueprints/03_products/core/specs/adapters/planning_methodology_adapter_faq.md` (si existe)\n\n**Verificar:**\n- ❓ ¿Blueprint existe?\n- ❓ ¿Define métodos para epic decomposition?\n- ❓ ¿EARS definidos y trazables?\n- ❓ ¿Describe cómo se integra con BacklogAdapter?\n\n**Posibilidad:** Si no existe blueprint, crearlo desde cero siguiendo el patrón de WorkflowMethodologyAdapter.\n\n### Capa 3: Verificar Coherencia 3 Capas (PENDIENTE)\n\n**Verificar (si los documentos existen):**\n- ❓ Protocol define epic decomposition → ¿Command permite configurar?\n- ❓ Protocol define routing rules → ¿Adapter implementa?\n- ❓ Protocol define artifact generation → ¿Adapter genera?\n- ❓ Ejemplos consistentes entre documentos\n\n**Si no existen:** Definir la coherencia desde cero usando los otros protocolos como referencia.\n\n### Capa 4: Verificar Código + Tests (PENDIENTE)\n\n**Archivos a buscar:**\n- `packages/core/src/adapters/planning_methodology_adapter/index.ts` (¿existe?)\n- `packages/core/src/adapters/planning_methodology_adapter/*.test.ts` (¿existen?)\n\n**Verificar:**\n- ❓ ¿Adapter existe o es stub?\n- ❓ ¿Implementa blueprint (si existe)?\n- ❓ ¿Tests cubren EARS?\n- ❓ ¿Integration con BacklogAdapter?\n\n**Posibilidad:** Puede que el adapter **NO EXISTA** aún (marcado como \"FUTURO\" en backlog_adapter.md línea 51). En ese caso, esta task incluye la implementación completa.\n\n### Capa 5: Verificar Schema Generabilidad (PENDIENTE)\n\n**Archivo:** `packages/blueprints/03_products/protocol/11_planning_methodology/planning_methodology_schema.yaml` (si existe)\n\n**Verificar que protocol documenta:**\n- ❓ `maxLength` para campos string\n- ❓ `pattern` para IDs y enums\n- ❓ `minItems`/`maxItems` para arrays\n- ❓ `required` fields listados\n- ❓ Estructura similar a workflow_methodology_record_schema.yaml\n\n**Si no existe schema:** Crearlo desde el protocol usando task_protocol.md como estándar de calidad.\n\n## Alcance de Trabajo\n\n### Escenario A: Protocol y Adapter YA EXISTEN\n\n**Trabajo:**\n1. Revisar documentos Protocol/Command/Adapter\n2. Identificar inconsistencias\n3. Actualizar documentos\n4. Revisar código\n5. Refactorizar si es necesario\n6. Verificar schema generabilidad\n\n**Tiempo:** 6-8 horas\n\n### Escenario B: Protocol EXISTE pero Adapter NO\n\n**Trabajo:**\n1. Revisar protocol existente\n2. Verificar schema generabilidad\n3. Crear adapter blueprint desde cero\n4. Implementar adapter completo\n5. Crear tests según EARS\n6. Integrar con BacklogAdapter\n\n**Tiempo:** 1-2 semanas\n\n### Escenario C: NI Protocol NI Adapter EXISTEN (Más Probable)\n\n**Trabajo:**\n1. Documentar protocol desde cero\n2. Crear schema YAML completo\n3. Crear adapter blueprint\n4. Decidir si implementar ahora o marcarlo como \"FUTURO\"\n5. Si se implementa: código + tests completos\n6. Si se pospone: documentar en Planning Brief\n\n**Tiempo:** 2-3 semanas (si se implementa completo)\n\n## Deliverables\n\n**Si Protocol/Adapter existen:**\n1. ✅ Análisis de coherencia completa\n2. ✅ Documentos actualizados\n3. ✅ Schema verificado/actualizado\n4. ✅ Código refactorizado\n5. ✅ Tests actualizados\n6. ✅ Verificación: tests pasando\n\n**Si Protocol/Adapter NO existen:**\n1. ✅ Protocol documentado desde cero\n2. ✅ Schema YAML completo\n3. ✅ Adapter blueprint creado\n4. ✅ Decisión: implementar ahora vs futuro\n5. ✅ Si futuro: documentar en Planning Brief con estimaciones\n6. ✅ Si ahora: implementación completa\n\n## Criterios de Aceptación\n\n**Mínimo (si está marcado como FUTURO):**\n1. ✅ Protocol documentado completamente\n2. ✅ Schema puede generarse 100% desde protocol\n3. ✅ Adapter blueprint creado y coherente\n4. ✅ Planning Brief detallado para implementación futura\n5. ✅ Referencias en BacklogAdapter actualizadas\n\n**Completo (si se implementa):**\n1. ✅ Protocol ↔ Command ↔ Adapter Blueprint 100% coherentes\n2. ✅ Schema generabilidad 100%\n3. ✅ Adapter implementado y funcionando\n4. ✅ Tests cubren todos los EARS\n5. ✅ Integration con BacklogAdapter funciona\n6. ✅ Epic decomposition funcionando\n7. ✅ TypeScript sin errores\n8. ✅ Todos los tests del core siguen pasando\n\n## Referencias\n\n**Pendientes de buscar/revisar:**\n- `packages/blueprints/03_products/protocol/11_planning_methodology/` (directorio completo)\n- `packages/blueprints/03_products/cli/specs/planning_command.md` (si existe)\n- `packages/blueprints/03_products/core/specs/adapters/planning_methodology_adapter.md` (si existe)\n- `packages/core/src/adapters/planning_methodology_adapter/` (si existe)\n\n**Referencia de calidad:**\n- `packages/blueprints/03_products/protocol/04_task/task_protocol.md` (estándar de documentación)\n- `packages/blueprints/03_products/core/specs/adapters/workflow_methodology_adapter.md` (patrón similar)\n\n**Referencia en código:**\n- `packages/core/src/adapters/backlog_adapter/index.ts` línea 51: `planningMethodologyAdapter?: IWorkflowMethodology; // Future`\n- `packages/blueprints/03_products/core/specs/adapters/backlog_adapter.md` línea 43: `planningMethodologyAdapter?: IWorkflowMethodology; // ❌ FUTURO`\n\n**Referencia de proceso exitoso:**\n- Task similar: FeedbackAdapter (5 capas, 23 archivos, 36 EARS, 742 tests)\n\n## Estimación\n\n**Complejidad:** Alta (puede requerir creación desde cero)\n**Tiempo estimado:** \n- Si solo verificación: 6-8 horas\n- Si creación de protocol: 1 semana\n- Si implementación completa: 2-3 semanas\n**Prioridad:** Medium (marcado como \"FUTURO\" en varios lugares)\n**Riesgo:** Medio (puede no existir aún)\n**Tags:** `core`, `planning-methodology`, `coherence-verification`, `schema-validation`, `protocol-sync`, `possible-creation`",
    "tags": [
      "core",
      "planning-methodology",
      "coherence-verification",
      "schema-validation",
      "protocol-sync",
      "possible-creation"
    ],
    "references": [],
    "cycleIds": [
      "1763344784-cycle-tareas-hurfanas-consolidadas"
    ]
  }
}